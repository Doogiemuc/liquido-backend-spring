package org.doogie.liquido.rest;

import lombok.extern.slf4j.Slf4j;
import org.doogie.liquido.datarepos.AreaRepo;
import org.doogie.liquido.datarepos.LawRepo;
import org.doogie.liquido.datarepos.PollRepo;
import org.doogie.liquido.datarepos.UserRepo;
import org.doogie.liquido.model.*;
import org.doogie.liquido.util.DoogiesRequestLogger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.core.mapping.RepositoryDetectionStrategy;
import org.springframework.data.rest.webmvc.config.RepositoryRestConfigurer;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.web.filter.OncePerRequestFilter;

/**
 * Configure the exposed REST HATEOAS services.
 *
 *  - Configure that only annotated repositories will be exposed as REST endpoints
 *  - make Models expose their IDs
 *  - Enable automatic generation of Swagger 2.0 REST API documentation
 *
 * Remark: base path for REST endpoint is configured in application.properties
 * https://spring.io/understanding/HATEOAS
 */
@Slf4j
@Configuration                  // a @Configuration is also a @Component
@EnableJpaAuditing(auditorAwareRef = "liquidoAuditorAware")   // automatic handling of UpdatedAt and CreatedAt
@EnableTransactionManagement    // enable @Transactional annotation
//@EnableSwagger2                 // enable autogenerated API documentation
//@Import({springfox.documentation.spring.data.rest.configuration.SpringDataRestConfiguration.class})
//@ComponentScan("org.doogie.liquido.rest")
public class LiquidoRepositoryRestConfigurer implements RepositoryRestConfigurer {

  /**
   * configure super advanced and elaborate logging of HTTP requests and responses
   * Log each request with ReqID, full Request URI and its duration in ms.
   * @return DoogiesRequestLogger
   */
  @Bean
  public OncePerRequestFilter requestLoggingFilter() {
    return new DoogiesRequestLogger();
  }


  @Override
  public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {
    log.debug("Configuring RepositoryRestconfiguration under basePath='"+config.getBasePath().toString()+"',  baseURI='"+config.getBaseUri().toString()+"'");

    // The base path for RepositoryRestResource is configured in application.properties. It's more prominent there
    // Keep in mind that this is only the base path for our HATEOAS endpoints. The base path for normal @RestControllers has to configured individually there.
    //config.setBasePath("/liquido/v2");

    // Only export data repositories that are annotated with @RepositoryRestResource(...)
    // In future versions this will be configurable in application.properties   spring.data.rest.detection-strategy=visibility   https://github.com/spring-projects/spring-boot/issues/7113
    config.setRepositoryDetectionStrategy(RepositoryDetectionStrategy.RepositoryDetectionStrategies.ANNOTATED);

    config.exposeIdsFor(UserModel.class);
    config.exposeIdsFor(AreaModel.class);
    config.exposeIdsFor(BallotModel.class);
    config.exposeIdsFor(DelegationModel.class);
    config.exposeIdsFor(LawModel.class);          // actually LawModel has its own LawProjection which exposes IDs.
    config.exposeIdsFor(PollModel.class);

		//MAYBE: when available in future version of spring: config.getCorsRegistry()
  }

  // see also LiquidoAuditorAware for handling @CreatedBy   https://jaxenter.com/rest-api-spring-java-8-112289.html

	@Autowired
	AreaRepo areaRepo;

	@Autowired
	UserRepo userRepo;

	@Autowired
	PollRepo pollRepo;

	@Autowired
	LawRepo lawRepo;

	/* DEPRECATED.  This worked, but now I have my  org.doogie.liquido.rest.deserializer.*  @JsonComponent
	 *
	 * Configure our JSON parse so that it convert from URIs to Entity instances
	 * that are loaded from the DB.
	 * Solution https://stackoverflow.com/questions/37186417/resolving-entity-uri-in-custom-controller-spring-hateoas/52938767#52938767
	 * @param objectMapper jackson JSON parser

	@Override
	public void configureJacksonObjectMapper(ObjectMapper objectMapper) {
		SimpleModule module = new SimpleModule();
		module.addDeserializer(AreaModel.class, new JsonDeserializer<AreaModel>() {
			@Override
			public AreaModel deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {
				String uri = p.getValueAsString();
				//p.getParsingContext().getCurrentName()+"s"  == "areas" :-)
				Long areaId = LiquidoRestUtils.getIdFromURI("areas", uri);
				AreaModel area = areaRepo.findById(areaId).get();
				return area;
			}
		});
		objectMapper.registerModule(module);
	}
  */



  /*
  @Override
  public void configureHttpMessageConverters(List<HttpMessageConverter<?>> messageConverters) {
    log.debug("====== adding HttpMessageConverter in RepositoryRestConfigurer");
    messageConverters.add(new JoinPollRequestConverter());     something that extends AbstractHttpMessageConverter<JoinPollRequest>
    super.configureHttpMessageConverters(messageConverters);
  }
  */


  /**
   * Automatically generated Swagger REST API documentation
   * @return the configured docket bean

  @Bean
  public Docket getSwaggerApi() {
    return new Docket(DocumentationType.SWAGGER_2)
        .select()
        .apis(RequestHandlerSelectors.any())
        .paths(PathSelectors.any())
        .build();
    //.pathMapping("/liquido");
  }
  */

  /*
   * This is necessary for being able to return plain JSON strings from REST controllers
   * http://stackoverflow.com/questions/15507064/return-literal-json-strings-in-spring-mvc-responsebody
   * @param messageConverters
  @Override
  public void configureHttpMessageConverters(List<HttpMessageConverter<?>> messageConverters) {
    StringHttpMessageConverter stringConverter = new StringHttpMessageConverter();
    stringConverter.setSupportedMediaTypes(Arrays.asList(
      MediaType.APPLICATION_JSON,
      MediaType.APPLICATION_JSON_UTF8,
      MediaType.TEXT_PLAIN
    ));
    messageConverters.add(stringConverter);
  }
  */




  /*  this manual validator for foreign keys was only necessary with MongoDB. Right now this is handled by MySQL foreign key constraints

  @Autowired        // Do not builder an instance with "new". Let Spring inject the dependency, so that it can ba handled by Spring.
  private DelegationValidator delegationValidator;

  @Override
  public void configureValidatingRepositoryEventListener(ValidatingRepositoryEventListener validatingListener) {
    log.info("========== adding beforeCreate validator     in RepositoryRestConfigurer");
    validatingListener.addValidator("beforeCreate", delegationValidator);
  }
  */

  /*

  /*
    https://stackoverflow.com/questions/22029727/using-validators-in-spring-data-rest-returns-http-500-instead-of-400
    Spring-data-rest returns HTTP 500 instead of 400 when validation fails, e.g. when required fields are missing in POST requests.
    This does help. But then this gets into conflictd with missing createdBy, which seems to be added later. *sic*
	@Bean
	public Validator validator() {
		return new LocalValidatorFactoryBean();
	}

	@Override
	public void configureValidatingRepositoryEventListener(ValidatingRepositoryEventListener validatingListener) {
		validatingListener.addValidator("afterCreate", validator());
		//validatingListener.addValidator("beforeCreate", validator());
		validatingListener.addValidator("afterSave", validator());
		validatingListener.addValidator("beforeSave", validator());
	}
	*/

}